#!.venv/bin/python
import subprocess
import argparse
import os
from glob import glob
from dataclasses import dataclass
import yaml
from typing import List
import sys

@dataclass
class Module:
    name: str
    source_dir: str
    manifest: dict


def discover_modules(path: str) -> List[Module]:
    modules = []
    for filename in glob(os.path.join(os.path.expanduser(path), "**", "module.yaml"), recursive=True):
        name = os.path.basename(os.path.dirname(filename))
        source_dir = os.path.abspath(os.path.dirname(filename))
        with open(filename) as f:
            manifest = yaml.safe_load(f)
        modules.append(Module(name=name, source_dir=source_dir, manifest=manifest))
    return modules


def load_config(filename: str) -> dict:
    with open(os.path.expanduser(filename)) as f:
        return yaml.safe_load(f)


def list_install_modules(config: dict, available_modules: List[Module]) -> List[str]:
    # Build a complete set of module names including their dependencies to
    # be installed
    install_modules = set()
    requirements = set(config["requiredModules"])
    while requirements:
        required_module = requirements.pop()
        if required_module in install_modules:
            continue
        module = next((m for m in available_modules if m.name == required_module), None)
        if not module:
            print(f"ERROR: Module '{required_module}' not found")
            sys.exit(1)
        requirements.update(module.manifest.get("requires", set()))
        install_modules.add(required_module)

    # Create an ordered installation list
    ordered_list = []
    while install_modules:
        item = install_modules.pop()
        module = next(m for m in available_modules if m.name == item)
        prerequisites = module.manifest.get("requires", [])
        if not all(p in ordered_list for p in prerequisites):
            install_modules.add(item)
            continue
        ordered_list.append(module)

    return ordered_list


def choose_install_method(module, config) -> str:
    if "bash" in module.manifest["installers"]:
        return "bash"

    return "unknown"


def install_module_using_bash(module, config):
    env = os.environ.copy()
    env["DOTFILES_MODULE_SOURCE_DIR"] = module.source_dir
    result = subprocess.run(["bash", "-c", module.manifest["installers"]["bash"]], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, env=env)
    sys.stdout.buffer.write(result.stdout)


def install_module(module, config):
    print(f"Installing module '{module.name}'...")
    method = choose_install_method(module, config)
    if method == "bash":
        install_module_using_bash(module, config)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-m", "--module-path", default="./mods/")
    parser.add_argument("-c", "--config", default="~/.dotfiles.yaml")
    args = parser.parse_args()

    available_modules = discover_modules(args.module_path)
    config = load_config(args.config)

    modules_to_install = list_install_modules(config, available_modules)
    for module in modules_to_install:
        install_module(module, config)


if __name__ == "__main__":
    main()
